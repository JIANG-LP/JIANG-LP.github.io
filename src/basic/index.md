# 前端笔记

## 红宝书 | 读书笔记

### 第1-3章

1.1一个完整的js实现包括啥？ 

ECMAscript,DOM, BOM

1.2ECMA的宿主环境有？ 

Web浏览器, node, flash, webview

1.3为何要DOM? 确保代码可以跨平台使用,

1.4DOM各级的区别？ 1级映射文档结构, 2级事件和支持CSS 3级加载和保存文档的方法

1.5BOM的作用是？ 让js可以控制页面以外的部分

2.1带src属性的script元素与其闭合标签嵌入JS代码有何问题？ 被忽略，不执行

2.2如何避免包含太多JS代码页面的空白？ js引用放在body页面后面

2.3为何最好一个页面 只 包含一个延迟脚本？ 因为延迟脚本不一定按顺序执行；

2.4为何建议异步脚本最好不要在加载期间修改DOM? 因为页面会先于脚本加载页面，容易出问题

2.5noscript元素中的内容何时出现？ 浏览器不支持脚本或者脚本被禁用

3.1为何要用严格模式？ 避免 不确定行为和不安全的操作。

3.2省略分号有何隐患？ 容易带来错误和降低性能（解析器需要推测）

3.3在控制语句中使用代码块的好处？ 让编码意图清晰和降低修改代码出错的几率

3.4为何说JS的变量是松散类型的？ 因为变量仅是保存值得占位符，可用来保存任何类型的数据

3.5js的数据类型有？ 基本类型：undefined，null，Number，Boolean，String 引用类型 Object

3.6typeof的作用？ 检测变量的数据类型

3.7typeof的返回值有？ undefined，number，boolean，string, object, function

3.8引入undefined的目的是？ 区分空对象指针与未初始化的变量

3.9对未声明变量只能执行的操作是？ typeof检测其类型

3.10为何建议显示初始化变量？ 便于使用typeof区分变量是未声明还是未初始化

3.11null值表示什么？ 空对象指针

3.12为何把变量显示初始化为undefined没必要，而把对象初始化为null却又必要？ 体现null作为空指针的惯例， 进一步区分null和undefined

3.13Boolean的字面值区分大小写吗？ 区分，所以False, 与false 不一样

3.140.1+0.2不等于0.3? 浮点数的精度是17位，存在舍入误差

3.15如何理解NaN？ 表示一个本来要返回数值的操作数未返回数值的情况

3.16JS中除0会阻止代码的执行吗？ 不会，因为它返回了NaN

3.17对象调用isNaN()函数有何不同？ 先调用valueOf()进行判断，视情况再调用toString()进行判断

3.18数值转型函数Number与parseInt/parseFloat有何区别？ 前者针对任何类型，后两者只针对字符串

3.19parseInt和parseFloat有何区别？ 一是parseFloat不忽略第一个小数点； 二是parseFloat始终忽略前导0； 三是parseFloat只解析十进制；

3.20怎样避免parseInt错误解析字符串？ 任何情况下明确基数。

3.21Number与parseInt解析空字符串时有何区别？ 前者返回 0， 后者返回NaN

3.22转换为字符串的方法及区别？ toString()通过指定基数，改变输出的值，null和undefined没有toString方法() String()将任何类型的值转换成字符串

3.23如何改变数值的toString()方法的 返回值？ 传入指定基数

3.24为何说Object是所有实例的基础？ Object所具有的任何属性和方法也存在于具体对象中。

3.25递增/减前置和后置的区别？ 前置时变量在语句执行前改变，后置则是在语句执行后改变

3.26系统怎样对 非数值 应用 位操作符 进行自动处理？ 使用Number()函数把该值转换为数值

3.27如何理解短路操作？ 第一个数决定结果，则不会操作第二个数

3.28比较数值与字符串时是如何转换的？ 字符串转换为数值

3.29任何操作数与NaN的比较结果是？ flase

3.30相等和全等的区别？ 全等不需要转换，性能更好

3.31为何NaN不等于NaN？ 逻辑上设计如此

3.32逗号操作符的赋值规则是？ 返回表达式最后一项

3.33为何for...in循环输出的属性名不可预测？ Js对象属性没没有顺序，

3.34为何不建议大量使用with语句？ 性能下降，调试困难

3.35为何switch语句比较时不发生转换？ 使用的是全等比较

3.36为何位于 return语句后的代码不会执行？ 函数执行return后会立即停止并退出

3.37JS函数中通过什么获取参数数组？ arguments对象

3.38为何JS中的函数不能实现重载？ 无法做到 参数类型和数量的不同
### 第4-6章
4.1 如何理解js变量松散类型本质？ 这决定了js只在特定的时间用于保存特定值得名字而已，变量的值及其数据类型可以在脚本的生命周期内改变。

4.2引用类型与基本类型有什么区别？ 基本类型是按值访问的，可以操作保存在变量中的实际值；引用类型的值是保存在内存中的对象，在操作对象时，实际上是在操作对象的引用，因为js不允许直接访问内存；引用类型可以为其添加属性，而基本数据类型则不可，尽管不报错；在复制变量时，基本类型是独立的两个变量，而引用类型中两个变量实际上引用的都是同一个对象，相互影响。

4.3 如何理解js中所有函数的参数都是按值传递的？ 在向参数传递基本数据类型的值时，被传递的值会被复制给一个局部变量，而在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化回反应在函数的外部；在参数为对象时，如果函数内部重写对象，此时的变量引用的只是局部对象，在函数执行完立即销毁，因此不会影响传进来的 外部对象。

4.4如何检测引用类型的具体类型？使用instanceof。

4.5如何理解函数的执行环境？ 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

4.6作用域链的作用是？ 保证对执行环境有权访问的所有变量和函数的有序访问。

4.7作用域的头尾是？ 前端始终是当前执行代码所在环境的变量对象，后端始终是全局执行环境的变量对象。

4.8延长作用域链的方法有？ 使用try-catch语句的catch块或者with语句。

4.9如何理解js的块级作用域？ 在ES6引入let关键字之前，不存在块级作用域，所以if或者for等语句执行完后，其内部声明的变量依然会存在于外部变量之中。

4.10为何初始化变量之前，最好先声明？ 一是在严格模式下，初始化未经声明的变量会导致错误；二是变量会自动被添加到全局环境，容易导致意外。

4.11如何理解js的垃圾收集机制？ 使用标记清除或引用计数的收集策略，周期性的找出那些不再使用的变量，然后释放其占用的内存。

4.12如何避免采用引用计数 垃圾收集策略时出现的循环引用问题？ 在不使用时，手工断开原生JS对象与DOM元素之间的连接，如将变量设置为null。

4.13为何分配给web浏览器的内存比桌面程序的少？ 主要出于安全考虑，防止运行JS网页耗尽全部系统内存而导致系统崩溃。

4.14优化内存的最好方式是？ 为执行中的代码只保存必要的数据，一旦不用，最好设置为null来释放其引用，让值脱离环境，以便垃圾收集器下次运行时将其回收。

4.15基本类型和引用类型在内存中的位置有何不同？ 前者保存在栈内存中，后者保存在堆内存中。

5.1js中创建对象实例的方法有？ 一是使用new操作符后跟Object构造函数；二是使用对象字面量表示法。

5.2如何选择访问js对象方法？ 除了必须使用变量来访问属性时采用方括号表示法，其他均建议使用点表示法。

5.3js中数组类型与其他语言最大的区别是？ 每一项可以保存任何类型的数据，并且数组大小是可以通过设置length属性进行动态调整的。

5.4创建数组的方式有？ 使用Array构造函数法和数组字面量表示法

5.5给数组构造函数传递一个值时处理规则是？ 如果传递的值时数值，则按照该数值创建给定项数的数组；如果是其他类型的，则会创建只有那一个值得数组。

5.6检测数组需要注意什么？ 当存在两个以上不同全局执行环境时，instanceof会难以区分不同的数组构造函数，所以在支持Array.isArray()方法的浏览器中使用该方法。

5.7js的数组是怎么实现栈和队列的数据结构的？ 使用push和pop方法模拟栈，使用shift和push，或unshift和pop模拟双向队列。

5.8数组的方法有？ isArray, toLocaleString, toString, valueOf, push, pop, shift, unshift, reverse, sort, concat, splice, indexOf, lastIndexOf, every, filter, forEach, map, some, reduce, reduceRight。

5.9js中定义函数的方法有？ 一是使用函数声明语法；二是使用函数表达式；三是使用Function构造函数（不推荐，解析了两次代码而影响性能）。

5.10js中函数为何没有指针？ 因为每个函数实际都是Function类型对象的实例，函数名只是一个指向函数对象的指针，不会与某个函数绑定，如果申明了两个同名函数，后面的函数会覆盖前面的函数。

5.11函数声明和函数表达式的区别？ js引擎会把函数声明提升到顶部，而表达式得到解析器执行到其所在的代码行才会被解释执行。

5.12函数名本身是变量有何好处？ 使得函数可以作为值来使用，传递参数或者作为函数内部的返回值等。

5.13如何理解函数内的arguments对象的callee属性？ 指向拥有该arguments对象的函数本身，一般在函数递归时用来消除函数执行与函数名的耦合。

5.14函数内部的属性和方法有？ argument和this对象，length和prototype变量，apply，call和bind toLocaleString, toString, valueOf。

5.15为何用apply和call？他们的区别？ 确保对象不与方法耦合的前提下，去扩充函数执行的作用域；接收参数的方式不同。

5.16Boolean, Number和String 特殊引用类型的作用是？特殊在哪？ 便于操作基本类型的值；特殊在对象的生存期，使用new操作符创建的引用类型实例，会在执行流离开当前作用域前一直保存在内存中，而特殊类型只存在代码执行的瞬间，并且不能再运行时为其添加属性和方法。

5.17使用new调用基本包装类型的构造函数，与调用同名转型函数的区别？ 前者返回 的类型为对象，而后者还是基本类型。

5.18String类型提供了那些方法和属性辅助js对字符串的解析和操作？ length,继承于对象的toLocaleString, toString, valueOf charAt, charCodeAt concat, slice, substr, subtring, indexOf,lastIndexOf, trim, toLowerCase, toLocaleLowerCase, toUpperCase, toLocaleUpperCase, match, search, replace,localeCompare, fromCharCode。

5.19Global对象的方法和属性有？ isNaN, isFinite, parseInt, parseFloat, encodeURI, encodeURIComponent, decodeURI, decodeURIComponent, eval； undefied, NaN, Infinity,Object, Array, Fuction, Boolean, String, Number。

5.20为何Math对象提供的计算功能比在JS中直接编写的要快得多啊？ 因为其属性和方法都是静态的，js引擎做了优化，少了解析代码的环节。

6.1js中的属性有？ 数据属性和访问器属性。

6.2如何修改数据属性的默认值？如何获取？ 使用Object.defineProperty()方法修改； 使用Object.getOwnPropertyDescriptor()方法获取；

6.3对象如何定义多个属性？ 使用Object.defineProperties()方法。

6.4使用Object构造函数或对象字面量创建对象的共同缺点是？ 产生大量重复代码；

6.5工厂模式解决了什么问题，还存在什么问题？ 解决了创建相似对象的问题，没有解决对象识别的问题。

6.6构造函数解决了什么问题，还存在什么问题？与普通函数有何区别？ 构造函数可通过其constructor属性来标识它的实例为特定的对象类型，即解决了创建相似对象问题，又解决了对象识别问题，但是每个方法都在实例重新创建了一遍，会导致不同的作用域链和标识符解析，且不同实例的同名函数不相等； 形式上是首字母大小写不同，本质上是调用方式不同，如果构造函数作为普通函数调用，属性和方法都会被添加到全局对象。

6.7函数中prototype属性的作用是？ 包含可以由特定类型的所有实例共享的属性和方法，其本身也是一个对象，其constructor属性指向包含该原型的构造函数。

6.8对象实例与原型中值的规则？ 实例可以访问原型中的值，却不能修改，且若实例添加了一个与原型同名的属性，将会屏蔽原型中的属性，阻止实例访问，只有通过delete操作符才能恢复去指向原型的连接。

6.9如何确定属性是实例属性还是原型属性？ 同时使用hasOwnProperty()方法和in操作符。

6.10使用对象字面量重写原型对象有何问题？ 其constructor属性指向Object了，需要特意将其显示的设置回特定的值，但会修改其枚举属性，所以最好使用Object.defineProperty()去单独设置；切断了构造函数与最初原型之间的联系，回导致错误。

6.11为何不推荐在原型对象中去定义新方法和属性？ 可能导致命名冲突，还有就是可能意外重写原生方法。

6.12原型对象还存在的问题？ 所有的属性都被所有的实例共享。

6.13怎么实现组合继承？ 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。

6.14寄生式继承为何会降低效率？ 因为不能做到函数复用。

6.15组合继承存在的最大问题是？ 总是调用两次超类函数。

6.16如何实现寄生组合式继承？ 通过构造函数来继承属性，通过原型链和混成形式来继承方法。
### 第7-9章
7.1 如何理解函数声明提升？ 执行代码之前会读取函数声明，这意味着可以把函数声明放在调用它语句的后面。

7.2 匿名函数的name属性是？ 空字符串。

7.3 怎样实现对函数的递归调用最安全？ 最好使用命名函数表达式，因为使用函数声明时进行引用赋值时，一旦将原来的函数名设置为null，就会导致错误；而使用arguments.callee代替函数名进行递归调用，在严格模式会不允许。

7.4什么是闭包？ 闭包是指有权访问另一个函数作用域中变量的函数。

7.5创建闭包的常见方式？ 在一个函数内部创建另一个函数。

7.6函数第一次调用时发生了什么？ 创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]],然后使用this，arguments和其他命名参数值来初始化函数的活动对象。

7.7作用域链的本质是？ 一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

7.8为何建议只在绝对必要时在考虑闭包？ 闭包换携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包会导致内存占用过多。

7.9匿名函数的this指向？ Window，因为它的执行环具有全局性。

7.10函数被调用时，其活动对象自动获取的特殊变量有？ this和arguments。

7.11闭包的副作用有？ 只能取得函数中任何变量的最后一个值； This指向不符合预期； 容易发生内存泄漏；

7.12如何看待重复声明变量？如何解决？ 对后续声明视而不见，但会执行变量的初始化；模仿块级作用域。

7.13模仿块级作用域的技术一般用在哪？ 全局作用域被用在函数外部，以限制向全局作用域中添加过多的变量和函数，从而避免命名冲突。

7.14什么是单例？ 只有一个实例的对象。

8.1BOM的事实标准是？ 浏览器之间共有的对象。

8.2window对象的双重角色是？ 既是JS访问浏览器窗口的接口，又是ECMAScript规定的Global对象。

8.3定义全局变量与在window对象上直接定义属性的区别？ 全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。

8.4引入 self 对象的目的是？ 与top和parent对象对应起来。

8.5为何不建议给setTimeout()方法第一个参数传递字符串？ 因为传递字符串可能导致性能损失。

8.6为何setTimeout()经过第二个参设置的时间后不一定会执行？ 因为JS是一个单线程语言，一定时间内只能执行一段代码，如果任务队列为空，添加的代码会立即执行，若非空，就需要等前面的代码执行后再可执行。

8.7为何取消间歇调用比取消超时调用重要？ 因为在不加干涉的情况下，间歇调用会一直执行下去

8.8为何location对象是BOM最有用的对象之一？ 因为它提供了与当前窗口中加载文档的有关信息，还提供了一些导航功能。

8.9location对象有何特殊之处？ 它既是window对象的属性，也是document对象的属性。

8.10为何要把reload()放在代码的最后一行？ 因为位于reload()调用之后的代码可能会也可能不执行，这取决了网络延迟或系统资源等因素。

8.11BOM的对象有？ 框架相关的top、parent、self对象 location对象、navigator对象、screen对象和history对象。

9.1什么时候使用客户端检测？ 找不到更通用的方法之后，万不得以

9.2能力检测的目标是？ 不是识别浏览器，而是识别浏览器的能力。

9.3能力检测需要注意什么？ 尽量使用typeof进行检测，该特性是否按照适当方式进行。

9.4在实际开发中，如何应用能力检测？ 应该将能力检测作为确定下一步解决方案的依据，而不是用来判断用户使用的是什么浏览器。

9.5怪癖检测的目标是？ 识别浏览器的特殊行为，存在什么缺陷。

9.6用户代理适用的情形有？ 不能直接准确使用能力检测或怪癖检测； 同一款浏览器在不同平台下具备不同的能力； 为了跟踪分析等目的。

9.7客户端检测方法有？ 能力检测、怪癖检测和用户代理检测。
### 第10-12章
10.1 什么是DOM？ DOM是针对HTML和XML文档的一个API。

10.2在确定节点类型时，如何确保兼容性？ 讲nodeType属性与数字值进行比较。

10.3为何说NodeiList是有生命、有呼吸的对象？ 因为它是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。

10.4DOM中操作节点的方法有？ appendChild();insertBefore(); replaceChild();removeChild(); cloneNode();normalize();

10.5document对象获取特定某个或某组元素引用的方法有？ getElementById()和getElementsByTagName() getElementsByName()(HTMLDocument类型有，XML类型没有)

10.6如果页面中多个元素的ID相同，getElementById()如何处理？ 只返回文档中第一次出现的元素；

10.7为何最好在比较之前将标签名转换为相同的大小写形式？ 因为HTML和XML中标签名大小写 规则不一样；

10.8操作特性的DOM方法有？ getAttribute();setAttribute();removeAttribute();

10.9attributes属性的方法有？ getNameItem();removeNameItem();setNameItem();item();

10.10操作节点中的文本有？ appendData();deleteData();insertData(); replaceData();splitText();substringData();

10.11什么是动态样式？ 在页面加载时不存在的样式，加载后才动态添加到页面中。

10.12为何DOM操作在处理,script和style元素时存在一些复杂性？ 因为这两个元素分别包含脚本和样式信息，浏览器会将他们和其他元素区别对待。

10.13如何理解DOM对性能的影响？ DOM操作往往是JS程序中开销最大的部分，因此要尽量减少对DOM的操作。

11.01选择符API的目的是？ 致力于让浏览器原生支持CSS查询，让解析和树查询操作可以在浏览器内部通过编译后的代码来完成，去改善性能。

11.02querySelectorAll()和querySelector的异同？ 接收的参数都是一个CSS选择符，若传入浏览器不支持的选择符或者选择符中有语法错误，都会抛出错误； 而前者返回的是所有的元素，后者只返回一个元素。

11.03返回NodeList的DOM方法杜具有的同样问题是？ 性能问题。

11.04Document的readyState属性的可能值有？ Loading 正在加载文档；complete已经加载完文档。

11.05如何避免在使用innerHTMl、outerHTML属性和insertAdjacentHTML()方法时可能导致的内存占用问题？ 手工删除被替换元素的所有事件处理程序和JS对象属性。

11.06H5中选择的滚动页面的标准方法为？ scrollIntoView()。

11.07为何要为DOM元素定义额外的属性？ 因为浏览器处理DOM元素间空白符的方式不一样。

12.01DOM2级和3级的目的是？ 扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理和特性检测能力。

### 第13-15章
13.1 JS和HTML的交互式如何实现的？ 通过事件实现的.

13.2什么是事件流？ 描述的是从页面中接收事件的顺序。

13.3什么是事件冒泡？ 事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点；

13.4事件捕获的目的是？ 在事件到达预订目标之前捕获它

13.5DOM2级规定事件流三阶段是？ 事件捕获阶段、处于目标阶段和事件冒泡阶段。

13.6什么是事件？ 用户或浏览器自身执行的某种动作。

13.7在HTML中指定事件处理程序的缺点有？ 一是存在时差；二是作用域链在不同浏览器会导致不同的结果；三是HTML与JS代码紧密耦合；

13.8 DOM 2级事件定义的两个方法和参数是？ addEventListener()和removeEventListener():要处理的事件名、作为事件处理程序的函数和一个布尔值（true表示在纱布或阶段调用事件处理程序，false表示在冒泡阶段调用事件处理程序）；

13.9使用DOM 2级方法添加事件处理程序的好处是？ 可以添加多个事件处理程序。

13.10为何多数时候，将事件处理程序添加到事件流的冒泡阶段？何时添加到捕获阶段？ 因为这样可以最大限度地兼容各种浏览器； 只在需要在事件到达目标前截获他的时候将事件处理程序添加到捕获阶段。

13.11IE中使用attachEvent与使用DOM 0级方法的主要区别是？ 事件处理程序的作用域，前者会在全局作用域，后者会在元素作用域内运行。

13.12使用addEventListener()和attachEvent()添加的匿名函数共同存在的问题是？ 不能移除

13.13事件对象包含什么？ 事件元素、类型和其他与特定事件相关的信息。

13.14如何理解事件对象的存活期？ 在事件处理程序执行期间存在，执行结束就被销毁。

13.15web浏览器中的事件类型有？ UI事件、焦点、鼠标、滚轮、文本、键盘、合成、变动和变动名称等事件。

13.16为何在JS中添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能？ 一是函数都是对象，对象会占内存，内存中对象越多，性能越差； 二是必须制定所有事件的处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间；

13.17从利用好事件处理程序的角度出发，有什么方法可以提升性能？ 限制数量、事件委托、移除事件处理程序

14.1获取 form 元素引用的方式有？ 一是看成与其他元素一样，使用getElementById等方法获取； 二是通过document.forms获取页面所有的表单；

14.2提交表单可能出现的最大问题是？如何解决？ 重复提交表单；一是第一次提交表单后就禁用提交按钮；二是利用onsubmit事件处理程序取消后续的表单提交操作。

14.3为何在处理文本框的值时，最好不要使用DOM方法？ 对value属性所做的修改，不一定会反映在DOM中。

14.4表单序列化在什么场景下使用最多？ 使用Ajax请求

15.1出现在canvas元素开始和结束标签中的内容何时显示？ 在浏览器不支持canvas元素时显示。

15.2在使用canvas元素之前需要干啥？ 检测getContext()方法是否存在。
### 第16-18章
16.1 什么是跨文档消息传递？ 指的是来自不同域的页面间传递消息

16.2 XDM的核心是？ postMessage()方法，其接受两个参数，一条消息和一个表示消息接收方来自哪个域的字符串；

16.3 如果传给postMessage()方法的第二个参数是'*‘，意味着什么？ 可以把消息发给任何域的文档

16.4 接收XMD消息时，会触发window对象的什么事件？ 以异步的形式触发message事件

16.5 触发message事件后，传给onmessage处理程序的事件对象包括什么信息？

  data 作为postMessage()第一个参数传入的字符串数据；
  origin 发送消息文档的所在域；
  source 发送消息文档的Window对象代理；

16.6 为什么不同通过event.source 这个代理对象访问window的其他任何信息？ 因为大多数情况下，event.source 这个代理对象并非真实的window对象

16.7 为何使用postMessage()，传入结构化数据时，建议先要在传入数据调用JSON.stringify()，在onmessage事件处理程序中调用JSON.parse()? 因为postMessage()最早第一个参数只允许传入字符串的，后来又部分浏览器支持传入结构化数据。

16.8 拖到元素时，依次触发的事件有？ dragstart -> drag -> dragend

16.9 当某个元素被拖动到一个有效的目标时，会依次发生的事件有？ dragenter -> dragover -> dragleave或drop

16.10 如何把任何元素变成有效的放置目标？ 重写dragenter和dragover事件的默认行为

16.11 H5规范中引入dataTransefer的作用是？ 在拖放操作时实现数据交互

16.12 H5为所有HTML元素引入的dragable属性作用是？ 通过设置它来控制元素是否可以拖动

16.13 为何要用canplayType检测浏览器是否支持特定媒体格式？ 因为并非所有浏览器支持所有的格式

16.14 历史状态管理器有啥用？ 不必卸载当前页即可修改浏览器的历史状态栈

17.1 JS中处理异常的标准方式是？ 使用try-catch语句

17.2唯一能够保证让所有浏览器都支持的错误对象属性是？ message属性

17.3 JS中ß的7中错误类型时？ Error EvalError RangeError referenceError SyntaxError TypeError URIError

17.4 Error这个基类型的主要目的是？ 供开发人员抛出自定义 错误

17.5 throw操作符的作用是？ 抛出自定义的错误，必须指定一个值

### 第19-21章
19.1 什么是E4X? 不是一门语言，而是对ECMAScript语言的可选扩展，为处理XML定义了新的语法，也定义了特定于XML的对象。

19.2 为何xml类型继承了所有对象默认的所有属性和方法？ 因为它继承自Object类型；

20.1 如何理解JSON? 它是一种数据格式，而不是一种编程语言。

20.2 JSON的语法可以表示哪三种的值？ 简单值、对象和数组。

20.3 JSON字符串和JS字符串的最大区别是？ JSON字符串必须使用双引号，使用单引号会导致语法错误；

20.4 JSON对象和JS对象字面量有何区别？ 一是没有声明变量；二是没有末尾分号；但是JSON对象中的任何属性名任何时候都必须加双引号；

20.5 为何JSON数据格式会流行？ 一是可以把JSON数据结构解析为有用的JS对象；二是与JS有类似的语法；

20.6 如何把JS对象序列化为一个JSON字符串？ 使用JSON.stringify()方法。

20.7 如何获得JSON字符串对应的JS值？ 使用JSON.parse()方法。

20.8 JSON.stringify()方法可以接受的另外的两个参数为？ 用于指定以不同的方式序列化JS对象，第一个参数是过滤器，可以是数组，也可以是函数；第二个参数是一个选项，表示是否在JSON对象中保留缩减。

20.9 为何要定义toJSON()方法？ 因为JSON.stringify()方法还不能满足某些对象进行自定义序列化的需求；

21.1通过XHR实现Ajax通信的主要限制是？

21.2跨资源共享的基本思想是？

21.3为何要实现一个跨浏览器的跨域请求？

21.4在跨资源共享之前，有哪些跨域技术？

21.5JSONP由什么组成？

21.6JSONP有什么缺点？

21.7实现Comet的方式有？

21.8如何选择SSE和Web Sockets?

### 第22-25章
22.1 为何JS使用函数指针非常简单？ 因为在js中，所有的函数都是对象

22.2 在安全类型检测中，为何使用toString()能保证返回一致的值？ 因为原生数组或函数的构造函数名与全局作用域无关

22.3 为何在web开发中区分原生与非原生对象非常重要？ 确切知道某个对象有哪些功能

22.4 当使用new调用时，构造函数内用到的this对象会指向哪？ 新创建的对象实例

22.5 当没有使用new操作符调用构造函数时，会有何问题？ 由于该this对象是运行时绑定，this会映射到全局对象上，导致错误对象属性的意外增加

22.6 如何创建作用域安全的构造函数？ 在进行任何更改之前，首先确认this对象是正确类型的实例，如果不是，那么会创建新的实例并返回，避免了在全局对象上意外设置属性

22.7 作用域安全的构造函数存在什么潜在问题？ 实现了作用域安全后，就相当于锁定了调用构造函数的环境，如果使用构造函数窃取模式继承且不使用原型链继承，这个继承很可能被破坏；

22.8 惰性载入的技巧用来干啥? 让代码运行得更快，比如存在大量if语句的代码块，即使只有一个if语句，也比没有if语句的慢；

22.9 实现惰性载入的技巧有？ 第一种是在函数在被调用时再处理函数，在第一次调用过程中，该函数会被覆盖为另一个按合适方式执行的函数；第二种为在声明函数时就指定适当的函数，基于自执行匿名函数；

22.10 绑定函数一般在什么场景使用？ 回调函数，事件处理程序以及setTimeout()和setInterval()，以便将函数作为变量传递时保留代码执行的环境；function bind(fn, context) { return function () { return fn.apply(context, arguments);};}

22.11 为何只有在必要时使用函数绑定？ 因为被绑定的函数与普通函数相比，会有更多的开销，比如需要更多的内存，也因为多重调用会慢一些；

22.12 函数柯里化的作用是？ 用于创建已经设置好了的一个或多个参数的函数；

22.13 函数柯里化和函数绑定的异同？ 都使用一个闭包返回一个函数，而柯里化中函数被调用时，返回函数还需要设置一些传入的参数；

22.14 为何js共享的本质让开发者头疼？ 任何任何对象都可以被同一运行环境的代码改变，开发人员很可能意外的修改别人的代码，甚至用不兼容的功能重写原生对象

22.15 不可扩展对象、密封对象和冻结对象的区别？ 调用了Object.preventExtensions()方法后，就不可以对该对象添加新的属性和方法了； 而调用了Object.seal()方法后，不仅不可扩展，而且不能删除该对象原有的属性和方法； 最严格的防篡改级别是冻结对象，调用了Object.freeze()方法后，不仅不能扩展和删除，甚至修改该对象的已有属性和方法都可以，只能去读。

22.16 关于定时器需要记住最重要的事情是？ 指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码

22.17 为何浏览器要限制JS能控制的内存大小和处理器时间？ 防止恶意的web程序吧计算机或者手机搞挂了

22.18 造成脚本长时间运行得原因有？ 一是过长的或过深嵌套的函数调用；二是进行大量处理的循环；

22.19 函数节流背后的基本思想是？ 某些代码不可以在没有简断的情况下连续重复执行： function throttle(method, context) { clearTimeout(method.tId); method.tId = setTimeout( fuction() { method.call(context); }, 100); } 如果没有纯context，则默认子全局环境下执行。

22.20 为何当代码中存在多个部分在特定时刻相互交互时，自定义事件非常有用？ 使用自定义对象有助于解耦相关对象，保持功能隔绝；

23.1什么是离线web应用？ 设备在不能上网的情况下仍然可以运行的应用

23.2 开发离线web应用的三部曲是？
## 面试常见问题
### HTML

#### 1.块级元素、行内元素、空元素、行内块元素

- 块级元素：可设置宽高边距，占满整行，会自动换行  
  div、 p、 h1 、h6、ol、ul、dl、table、form、address、blockquote
- 行内元素：无法设置宽高边距，不会占满整行，不会自动换行  
  a span img input select
- 空元素：没有内容的 HTML 元素被称为空元素，空元素是在开始标签中关闭的  
  br hr img input link meta
- 行内块元素：  
  img input

#### 2.html 语义化

- ① 用正确的标签做正确的事情；

- ②html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;

- ③ 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;

- ④ 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

#### 3.src 和 href 的区别

- src: 指向外部资源的位置，请求 src 资源时会将其下载并应用到文档内；  
  当浏览器解析到 src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载和处理），直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。
- href: 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。  
  若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。

#### 4.<!DOCTYPE>的作用

- 告诉浏览器用什么文档标准来解析这个文档。如果不放入<！doctype html>标签，HTML5 不会工作。浏览器将不能识别出它是 HTML 文档，同时 HTML5 的标签将不能正常工作。

#### 5.h5 新特性

- 更多的语义化标签：header、footer、nav、hgroup、article、section、time 等；
- 对媒体支持：使用 audio 和 video 标签避免先前以插件的方式播放音频、视频带来的麻烦；
- Canvas 绘图：实现在 HTML 页面中绘制图形和图像，且所有的绘图内容都是使用 js 来控制的；
- SVG 绘图技术：矢量图技术，可以无限缩放；
- 实时通信：HTML5 提供了对 Web Sockets 的支持；
- Geolocation： 地理定位，使用浏览器获得客户端所在的地理坐标；
- 客户端本地存储：会话级客户端存储 sessionStorage 和跨会话级客户端存储 localStorage；
- 拖放 API：在 HTML 页面中实现 GUI 程序中的“拖”和“放”操作，提供了七个新事件；
- 文件离线储存：浏览器就会根据 manifest 文件的内容下载相应的资源，并进行离线存储。
- 移除的元素：  
  纯表现的元素：basefont，big，center，font, s，strike，tt，u;  
  对可用性产生负面影响的元素：frame，frameset，noframes；

#### 6.web 标准和 w3c 标准

- web 标准：分为结构、表现和行为
- W3C 标准：提出了更规范的要求
  1、结构方面：标签字母要小写，标签要闭合，标签要正确嵌套
  2、css 和 js 方面：尽量使用外链写法，少用行内样式，属性名要见名知义

#### 7.Label 的作用

- label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。
  解析：两种用法：一种是 id 绑定，一种是嵌套。

#### 8.Web Storage

- sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。
- localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

#### 9.常见的浏览器端存储的方式

- 1.Cookie：  
  cookie 会随着每次 HTTP 请求头信息一起发送，无形中增加了网络流量，另外，cookie 能存储的数据容量有限，根据浏览器类型不同而不同，IE6 大约只能存储 2K。  
  Cookie 可以实现记录访问者的信息、在页面之间传递信息、自动识别用户。

- 2.sessionStorage：  
   使用于 Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者 Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。
  缺点：IE 不支持、不能实现数据的持久保存。

- 3.localStorage：  
   localStorage 是 Web Storage 互联网存储规范中的一部分，现在在 Firefox3.5、Safari 4 和 IE8 中得到支持。  
  缺点：低版本浏览器不支持。

#### 10.对浏览器内核的理解

- 主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。

  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。  
  JS 引擎则：解析和执行 javascript 来实现网页的动态效果。
  最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

#### 11.元素的 alt 和 title 的异同

- 在 alt 和 title 同时设置的时候，alt 作为图片的替代文字出现，title 是图片的解释文字。

### CSS

#### 1.实现导航栏吸顶

- 1.sticky : 粘性定位

```
      /* 粘性定位 ( IE 浏览器不生效 ) */
      position: sticky; // 粘性定位
      top: 0; // 粘性定位
```

- 2.fixed : 固定定位

```
      /* 固定定位 ( 浏览器放大跑偏 ) */
      position: fixed;
      top: 90px; // 脱离文档流, 不占页面位置
      width: 100%;
      z-index: 999; // 视情况而加
```

- 3.relative + absolute 结合使用

```
// 实现类似于 fixed 固定定位的效果
position: relative; // 父 父相

      // 子 绝对定位
      // 通过给 父父级 .fufu 添加相对定位来实现类似于 fixed 固定定位的效果
      position: absolute;
      top: 0;
      left: 184px;
      width: 100%;
      z-index: 99; // 视项目情况而加
```

#### 2.绘制三角形

- 方法一：设置宽高都为 0。然后把边框设置为一边有颜色，其他三遍透明
- 方法二：设置 border:20px solid transparent;然后再设置 border-top:20px solid red;

  详细：https://blog.csdn.net/weixin_44015669/article/details/115663156?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168206417216800182137356%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168206417216800182137356&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-115663156-null-null.142^v86^insert_down28,239^v2^insert_chatgpt&utm_term=css%20%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2&spm=1018.2226.3001.4187

#### 3.伪类 伪元素

- 伪类和伪元素都是用来表示文档树以外的"元素"；
- 伪类和伪元素分别用单冒号:和双冒号::来表示；
- 伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类；

#### 4.盒模型

- css 盒模型包括标准模型和 IE 盒模型。
- 两个都包含 content/padding/border/margin，区别是 IE 盒模型（怪异盒模型）的 width 表示 content+padding+border，标准盒模型的 width 只包含 content。

#### 5.css3 新特性

- 圆角（ border- radius）；

- 阴影（box- shadow）；

- 对文字加特效（text- shadow）；

- 线性渐变（ gradient）；

- 变换（ transform ） 如（ transform:rotate（9deg）scale（0.85,0.90）translate（0px, 30px）skew（-9deg,0deg）；// 旋转、缩放、定位、倾斜。

- 更多的 CSS 选择器；

- 多背景设置；

- 色彩模式，如 rgba；

- 伪元素::selection;

- 媒体查询；

- 多栏布局；

- 图片边框（ border-image）。

#### 6.画一条 0.5px 的线

```
div {
	background:black;//一定是background而非color
	width:100%;
	height:1px;
    <!-- scale缩放 -->
	transform:scaleY(0.5)
}
```

- 给容器设置伪元素，设置绝对定位，宽高是 200% ，边框是 1px；
- 利用线性渐变，一半有颜色，一般透明；

#### 7.浮动清除

- 使用带 clear 属性的空元素在浮动元素后使用一个空元素如`<div class="clear"></div>`，并在 CSS 中赋予.clear{clear:both;}属性即可清理浮动。亦可使用`<br class="clear" />`或`<hr class="clear" />`来进行清理。

none：元素不会向下移动清除之前的浮动。  
left/right：元素被向下移动用于清除之前的左或右浮动。  
both：元素被向下移动用于清除之前的左右浮动。

- 使用 CSS 的 overflow 属性给浮动元素的容器添加 `overflow:hidden;`这样做就隐藏了浮动元素。或 `overflow:auto;`可以清除浮动，这是自动隐藏。

overflow 是当块级元素过大，超过所容纳的空间时进行的操作。

- 给浮动的元素的容器添加浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。
- 使用邻接元素处理什么都不做，给浮动元素后面的元素添加 clear 属性。
- 使用 CSS 的:after 伪元素结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）。

```
   .clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
        content: "";
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
        }

```

#### 8.实现元素的垂直居中

- 1.使用绝对定位 + transform，给子元素添加如下样式

这种方式比较常用，父子元素都不确定宽高的情况也适用。

如果子元素的宽高确定的话，translate 中的值也可以设置为子元素宽高的一半，即 `transform: translate(-100px, -100px);`

```
.work {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
}
```

- 2.使用绝对定位 + margin，给子元素添加如下样式

这种方式适合子元素宽高确定的情况，给 margin-top 设置百分比的大小将不生效，即 margin-top: -50%;不能达到垂直居中的效果

```
.work1 {
      position: absolute;
      top: 50%;
      left: 50%;
      margin-top: -100px;
      margin-left: -100px;
}
```

- 3.使用绝对定位 + margin: auto，给子元素添加如下样式

父子元素宽高都未知时也适用。

```
.work2 {
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      left: 0;
      margin:auto;
}
```

- 4.父元素使用 flex 布局，并设置相关的属性值为 center

这种方式要求父元素的高度是确定的，百分比形式的高度将不能生效。

```
.par-work {
    height: 100vh;
    display:flex;
    justify-content:center;
    align-items:center;
}
```

- 5.使用 table-cell 实现

这种方式需要父元素的宽高都是确定的，才能保证子元素在父元素中垂直水平都居中。

```
.par-work2 {
    height: 500px;
    width: 500px;
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
.son-work2 {
    display: inline-block;
}
```

- 6.使用 grid 布局

这种方式适用于父元素高度确定的情况。

```
.par-work3 {
    display: grid;
    height: 500px;
}
.son-work3 {
    align-self: center; /*设置单元格内容的垂直位置*/
    justify-self: center; /*设置单元格内容的水平位置*/
}
```

#### 9. auto 和 100%区别：

- 1.  auto 是在屏幕内操作，如果有边框，则内部的 content 缩小，边框不会超出屏幕，会自动适应屏幕。
- 2.  100%指的的 content+padding，如果添加 border 就会超出屏幕。

#### 10.阴影

- **文本阴影**
  1. text-shadow: 10px 10px 3px yellow , 10px -10px 2px red;
  2. 阴影 text-shadow: 水平方向位移 垂直方向位移 模糊程度 颜色 写多个阴影的时候只需要用“，”隔开就行。
- **盒子阴影**
  1. box-shadow:水平方向位移 垂直方向位移 (阴影大小) 模糊程度 颜色 (内 inset 或外阴影，默认外阴影)。

#### 11.弹性布局

```
1. display:flex;
2. **flex-direction**: column;修改主轴为竖直排列
   1. row;主轴为水平排列
   2. row-reverse；主轴水平反向排列
   3. column-reverse;主轴垂直方向反向排列
3. **justify-content**:调整主轴对齐方向
   1. flex-start  左对齐
   2. center  居中对齐
   3. flex-end   右对齐
   4. space-between  两端对齐
   5. space-around 距离环绕
4. **align-items**:调整侧轴对齐方向。同上
5. **flex-wrap**: wrap;折行显示   如果没有折行显示，使用 display: flex;就会在一行里面显示
6. **align-content**:行间距。属性同上

```

#### 12.移动端布局

- css 像素: 设备的独立像素。
- 物理分辨率: 设备真正的像素。

设备像素比=物理像素/css 像素

#### 13.css 优先级算法怎么计算

```
1. **!important>内联样式>id>class>标签>通配(*)**
2. css权重计算
   1. 内联样式（style） 权重值：1000
   2. id选择器                 100
   3. 类选择器                  10
   4. 标签&伪类元素选择器         1
   5. 通配（> + *)               0

```

#### 14.sass、less

- 1.原理  
  1.1 Less 定义：是一种动态的样式语言,使 CSS 变成一种动态的语言特性，如变量、继承、运算、函数。Less 既可以在客户端上面运行(支持 IE6 以上版本、Webkit、Firefox),也可以在服务端运行(Node.js)

  1.2 SaSS 定义：是一种动态样式语言，SaSS 里面的语法属于缩排语法，对于之前的 css 相比，多出了很多功能，更容易阅读

  1.3 预处理器。Less 和 SaSS 都属于预处理器，它会定义一种新的语言，其总体思想是为 CSS 增加一些编程的特性，将 CSS 作为目标生成文件

- 2.区别  
  2.1 编译环境  
  Sass 是在服务端上面处理的，之前是 Ruby,现在是 Dart-Sass 或者是 Node-Sass，但是 Less 在编译时，需要引入 less.js 来处理 Less 代码输出 CSS 到浏览器上，也可以在开发服务器上将 Less 语法编译成 css 文件，输出 CSS 文件到生产包目录，也有在线编译地址。

  2.2 变量符  
  Less 是@，而 Sass 是$

  2.3 输出设置  
  Less 没有输出设置，而 Sass 有 4 种输出选项，如下
  nested：嵌套缩进的 css 代码
  expanded：展开的多行 css 代码
  compact：简洁格式的 css 代码
  compressed：压缩后的 css 代码

  2.4 Sass 支持条件语句，可以使用 if{}else{},for{}循环等等，而 Less 不支持。

- 3.优点  
  3.1 提供 CSS 缺失的样式层复用机制  
  3.2 减少冗余代码  
  3.3 提高样式代码的可维护性  
  3.4 结构清晰，便于扩展可以方便的屏蔽浏览器私有的语法差异  
  3.5 轻松实现多重继承，完全兼容了 CSS 代码，提高了开发效率。

### JavaScript/Typescript

#### 1.js ts 区别

它们都是脚本语言。JavaScript 是轻量级的解释性脚本语言，可嵌入到 HTML 页面中，在浏览器端执行。而 TypeScript 是 JavaScript 的超集（ts 是微软开发的开源编程语言），即包含 JavaScript 的所有元素，能运行 JavaScript 的代码，并扩展了 JavaScript 的语法。（ts 包含了 js 的库和函数，ts 上可以写任何的 js，调用任何的 js 库，可以在 ts 中使用原生 js 语法）。相比于 JavaScript ，它还增加了静态类型、类、模块、接口和类型注解方面的功能，更易于大项目的开发。

区别：

1、TypeScript 引入了 JavaScript 中没有的“类”概念

2、TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中

3、js 没有重载概念，ts 有可以重载

4、ts 增加了接口 interface、泛型、类、类的多态、继承等

5、ts 对比 js 基础类型上，增加了 void/never/any/元组/枚举/以及一些高级类型

js 有的类型：boolean 类型、number 类型、string 类型、array 类型、undefined、null

ts 新增的类型：tuple 类型（元组类型）、enum 类型（枚举类型）、any 类型（任意类型）

void 类型（没有任何类型）表示定义方法没有返回值  
never 类型：是其他类型（包括 null 和 undefined）的子类型，代表从不会出现的值这意味着声明 never 变量只能被 never 类型所赋值

js 变量是没有类型的，即 age=18，age 可以是任何类型的，可以继续给 age 赋值为`age=”aaa”`  
Ts 有明确的类型(即：变量名:number(数值类型)) `eg：let age: number = 18`

ts 需要静态编译，它提供了强类型与更多面向对象的内容。  
ts 最终仍要编译为弱类型，基于对象的原生的 js，再运行。故 ts 相较 java/C#这样天生面向对象语言是有区别和局限的  
ts 是由微软牵头主导的，其语法风格与概念主要来自 C#，理解起来学过 java 的更容易理解

ts 优势

1、类型化思维方式，使开发更严谨，能帮助开发人员检测出错误并修改，提前发现错误，减少改 Bug 时间

2、类型系统提高了代码可读性，便于开发人员做注释，维护和重构代码更加容易

3、补充了接口、枚举等开发大型应用时 JS 缺失的功能

【JS 的类型系统存在"先天缺陷"，绝大部分错误都是类型错误(Uncaught TypeError)】

4、TypeScript 工具使重构更变的容易、快捷

5、类型安全功能能在编码期间检测错误，这为开发人员创建了一个更高效的编码和调试过程

#### 2.闭包

- 闭包：就是能够读取外层函数内部变量的函数。
- 闭包需要满足三个条件：  
  访问所在作用域；  
  函数嵌套；  
  在所在作用域外被调用 。
- 优点： 可以重复使用变量，并且不会造成变量污染 。
- 缺点： 会引起内存泄漏
- 使用闭包的注意点：  
  由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

  闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

#### 3.原型和原型链

- 原型就是一个为对象实例定义了一些公共属性和公共方法的对象模板。
- 原型链

```
对象之间的继承关系通过构造函数的prototype指向父类对象，直到指向Object对象为止形成的指向链条。

通俗讲： 原型链是原型对象创建过程的历史记录。

注：在javascript中，所有的对象都拥有一个__proto__属性指向该对象的原型（prototype) 。
```

#### 4.es6 新特性

https://blog.csdn.net/ZLJ_999/article/details/124122540?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168206751916800227426337%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168206751916800227426337&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124122540-null-null.142^v86^insert_down28,239^v2^insert_chatgpt&utm_term=es6%E6%96%B0%E7%89%B9%E6%80%A7&spm=1018.2226.3001.4187

#### 面试题汇总

https://blog.csdn.net/chen3647/article/details/125286196?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168206626016800215094911%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168206626016800215094911&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125286196-null-null.142^v86^insert_down28,239^v2^insert_chatgpt&utm_term=js%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187

## 框架

### Vue

### React

## 小程序

## 性能
